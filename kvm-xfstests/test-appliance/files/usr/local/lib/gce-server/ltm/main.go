/*
Webserver endpoints for the gce-xfstests LTM (lightweight test manager).

This stand-alone server handles requests sent by the client-side scripts.
The endpoints are:
	/login (deprecated) - to authenticate a user session, enforced by the flask
	webserver in the previous implementation.

	/gce-xfstests - takes in a json POST in the form of LTMRequest, and runs the
	tests.

*/
package main

import (
	"encoding/json"
	"net/http"

	"gce-server/logging"
	"gce-server/server"
	"gce-server/util"

	"github.com/sirupsen/logrus"
)

// configurable user name for naming LTM files
const (
	LTMUserName = "ltm"
)

/*
runTests is the end point for a gce-xfstests test request from user.

orig_cmdline is a base64 encoding of the command line arguments.
A ShardSchedular is constructed to arrange the tests in multiple
ShardWorkers, and then starts these shards in separate go routines.
Returns the info generated by the sharder
*/
func runTests(w http.ResponseWriter, r *http.Request) {
	defer server.FailureResponse(w)

	log := server.Log.WithField("endpoint", "/gce-xfstests")

	var c server.TaskRequest
	err := json.NewDecoder(r.Body).Decode(&c)
	logging.CheckPanic(err, log, "Failed to parse json request")

	// TODO: implement password validation
	log.WithFields(logrus.Fields{
		"cmdLine":      c.CmdLine,
		"options":      c.Options,
		"extraOptions": c.ExtraOptions,
	}).Info("Received test request")

	testID := util.GetTimeStamp()
	if c.ExtraOptions == nil {
		log.WithField("testID", testID).Info("User request, generating testID")
	} else {
		testID = c.ExtraOptions.TestID
		log.WithField("testID", testID).Info("KCS request, use existing testID")
	}

	response := server.SimpleResponse{
		Status: true,
		TestID: testID,
	}

	if c.ExtraOptions == nil {
		if c.Options.BranchName != "" {
			if !c.Options.UnWatch {
				log.Info("User requests a git watch, launching git repo monitor")
				watcher := NewGitWatcher(c, testID)
				go watcher.Run()

				response.Msg = "Initiating git repo monitor"
			} else {
				log.Info("User requests a git unwatch, terminating git repo monitor")
				StopWatcher(c)

				response.Msg = "Terminated git repo monitor"
				response.TestID = ""
			}
		} else if c.Options.CommitID != "" {
			log.Info("User requests a kernel build, calling KCS")
			go StartBuild(c, testID)

			response.Msg = "Calling KCS to build the kernel"
		}
	}

	if response.Msg == "" {
		sharder := NewShardSchedular(c, testID)
		sharder.Dump("/root/mock_sharder.json")
		// sharder := ReadSharder("/root/mock_sharder.json")
		log.Info("Test sharder created")
		go sharder.Run()

		response.Msg = "Launching tests"
	}

	log.WithField("response", response).Info("Sending response")
	js, _ := json.Marshal(response)
	w.Header().Set("Content-Type", "application/json")
	w.Write(js)
}

func main() {
	defer logging.CloseLog(server.Log)

	server.Log.Info("Launching LTM server")
	http.HandleFunc("/", server.Index)
	http.HandleFunc("/login", server.Login)
	http.HandleFunc("/gce-xfstests", runTests)
	err := http.ListenAndServeTLS(":443", server.CertPath, server.SecretPath, nil)
	logging.CheckPanic(err, server.Log, "TLS server failed to launch")
}
